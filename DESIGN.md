# Typed Functional Lisp – 設計方針（Draft）

本ドキュメントは **S式を正規ASTとする関数型Lisp** に、
ML/Haskell 系の型表現力を重ねる設計方針の草案である。
表面構文は豊かでも、**意味は常に一意**であることを最優先とする。

## 1. 目的と思想

* **S式を正規ASTとする**
* 表面構文は増やしてよいが、**意味は単純に保つ**
* 曖昧な構文は推測せず、**コンパイルエラーにする**
* 型・関数・型コンストラクタを「関数的」に統一する
* 中置構文・連鎖構文は **desugar（正規化）前提**

> 「書きやすさ」より「意味の一意性」を優先する。

---

## 2. 正規形（Canonical Form）

* 内部ASTは **最小限のS式のみ**で構成される
* 中置演算・連鎖・型注釈などは **すべて正規形に変換**される
* 型検査・評価器は **正規形のみ**を扱う

例：

```lisp
(x : (Int -> Int))
```

は内部的に

```lisp
(: x (-> Int Int))
```

へ正規化される。

---

## 3. 型システム概要

### 3.1 型は式である

* 型は「型レベルの式」
* 型コンストラクタは **関数**
* 型引数はカリー化・部分適用可能

例：

```lisp
(Result String)        ; Type -> Type
(Result String Error)  ; Type
```

> 型システムの最小ルール（型変数・多相・束縛など）は別ドキュメントに分離する。

---

### 3.2 関数型

関数型コンストラクタ：

```lisp
(-> A B C)
```

意味：

```text
A -> B -> C
```

* **右結合**
* カリー化がデフォルト

---

### 3.3 タプル型

```lisp
(, A B C)
```

表面構文糖衣：

```lisp
(A, B, C)
```

---

## 4. 型注釈演算子 `:`

### 4.1 `:` は2項演算子

* 常に **2項**
* 正規形：

```lisp
(: expr Type)
```

表面構文：

```lisp
(expr : Type)
```

---

### 4.2 括弧必須ルール（重要）

曖昧さを排除するため、右辺は **単一の型式**でなければならない。

* ❌ `x : Int -> Int`
* ✅ `x : (Int -> Int)`

---

### 4.3 大域・局所の統一

* `:` は **唯一の型注釈構文**
* トップレベルでは「大域型宣言」
* 式中では「局所型注釈」

例：

```lisp
(: f (-> Int Int Int))

(def (f x y)
  (+ x y))
```

---

## 5. 定義フォーム `def`

### 5.1 def の役割

* `def` は **束縛を作る唯一の構文**
* 関数定義・値定義を統一

正規形：

```lisp
(def ((name : Type) arg*) body...)
```

---

### 5.2 関数定義例

```lisp
(def ((f : (Int -> Int -> Int)) x y)
  (+ x y))
```

内部正規化イメージ：

```lisp
(def (: f (-> Int Int Int))
  (lambda (x y)
    (+ x y)))
```

---

### 5.3 値定義例

```lisp
(def ((x : Int))
  (+ 1 2))
```

---

## 6. 中置演算の設計方針

### 6.1 中置は糖衣

* 中置構文は **表面構文のみ**
* 正規形ではすべて前置S式になる

---

### 6.2 中置可能な演算子の宣言

中置構文の挙動は **関数定義とは分離**して宣言する。

```lisp
(defop + (:infix :chain :assoc left))
```

* `:infix` : 中置として使用可能
* `:chain` : 同一記号の連鎖を許可
* `:assoc left/right` : 連鎖時の畳み方向

---

### 6.3 連鎖ルール

* **同一記号のみ連鎖可能**
* 異なる演算子が混ざったらエラー
* 優先順位は導入しない（括弧で明示）

例：

```lisp
1 + 2 + 3    ; OK
1 + 2 * 3    ; エラー
```

---

### 6.4 連鎖の正規化

```lisp
1 + 2 + 3
```

は、`assoc left` の場合：

```lisp
(+ (+ 1 2) 3)
```

`assoc right` の場合：

```lisp
(+ 1 (+ 2 3))
```

---

## 7. 属性設計の原則

* `:chain` は単独指定不可
* `:chain` ⇒ `:infix` 必須
* `:assoc` ⇒ `:chain` 必須
* 条件違反は **定義時にコンパイルエラー**

---

## 8. エラー優先設計

以下はすべて **エラー**とする。

* 曖昧な中置連鎖
* 括弧なし複合型注釈
* 宣言されていない中置演算子の使用
* 意味を推測しない構文

---

## 9. 追加で議論したいポイント（提案）

以下は今後の設計議論で明確化したい項目。

1. **演算子宣言と型の関係**
   * `defop` と `def` の順序依存（先に宣言必須か、後から宣言可か）。
   * `defop` が参照する「本体の関数」をどこで識別するか。
2. **型注釈のスコープ**
   * `(: f ...)` と `def` の結合規則をどこまで許すか。
3. **エラー方針の粒度**
   * 推測を排する方針に沿って、どこまでエラーを先に出すか。
4. **正規形の最小コア**
   * `def` / `lambda` 以外にコアとして必要なフォームの決定。

---

## 10. 設計まとめ

* **S式が唯一の真実**
* 型・関数・演算子はすべて関数的に扱う
* 中置・連鎖は sugar として限定的に導入
* 曖昧な構文は即エラー
* 拡張は常に「正規化レイヤ」を通す

> 構文は豊かでも意味は常に一意であることを最優先とする。
