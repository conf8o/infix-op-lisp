# コレクション型

リストとタプルについては、特別なリテラル表現を用意し、パターンマッチングを可能にします。

```
; ============================================================
; 1. リスト
; ============================================================

; コードとしてのリストと、コレクションとしてのリストは区別します。
; `()` で囲われたデータはコードとしてのリストであり、`[]`で囲われたデータはコレクションとしてのリストです。

; --- 表層形式(式) ---
[]                 ; 空リスト
(x :: xs)          ; 中置cons(右結合)
[a b c]            ; リストリテラル(空白区切り)


; --- 正規形式(式) ---
[]                 ; プリミティブな空リスト値
(:: x xs)          ; 正規プレフィックス形式

; 脱糖規則:
; [e1 e2 ... en]
;   -> (e1 :: (e2 :: (... (en :: []) ...)))
;
; (x :: y)
;   -> (:: x y)


; --- 型 ---
; List : Type -> Type
; [] : (List a)
; (::) : a -> (List a) -> (List a)


; --- パターンマッチング(リスト) ---
; 表層パターン:
[]                 ; 空リストパターン
(p1 :: p2)         ; consパターン
[p1 p2 ... pn]     ; リストリテラルパターン

; 脱糖規則(パターン):
; []               ==> []
; (p1 :: p2)       ==> (:: p1 p2)
; [p1 ... pn]      ==> p1 :: (p2 :: (... (pn :: []) ...))

; 意味論:
; - パターン位置では評価は行われません
; - パターン中の(::)は構造の分解を行います
; - (::)は右結合です
; - リストパターンは構造束縛のためのものであり、関数呼び出しではありません


; ============================================================
; 2. タプル
; ============================================================

; --- 表層形式(式) ---
{}                 ; Unit (Tuple0)
{a}                ; Solo a (Tuple1)
{a b}              ; Tuple2
{a b c}            ; Tuple3
; 空白区切りの要素
; カンマは演算子ではありません


; --- 正規形式(式) ---
{}         ==> (Unit)
{a}        ==> (Solo a)
{a b}      ==> (Tuple2 a b)
{a b c}    ==> (Tuple3 a b c)
; ...

; TupleNコンストラクタは通常のコンストラクタです
; 正規形式では標準的な関数適用として使用されます


; --- 型 ---
; Unit   : Type
; Solo   : Type -> Type
; Tuple2 : Type -> Type -> Type
; Tuple3 : Type -> Type -> Type -> Type
; ...

; 例:
; 1      : Int
; {1}    : (Solo Int)
; 1 != {1}


; --- パターンマッチング(タプル) ---
; 表層パターン:
{}                 ; Unit
{p}                ; Solo
{p q}              ; Tuple2
{p q r}            ; Tuple3

; 脱糖規則(パターン):
; {}        ==> (Unit)
; {p}       ==> (Solo p)
; {p q}     ==> (Tuple2 p q)
; {p q r}   ==> (Tuple3 p q r)
; ...

; 意味論:
; - タプルパターンは構造の分解のみを行います
; - パターン位置では評価は行われません
; - アリティは被検査対象の静的型により固定されます
; - 同じ被検査対象に対して複数のタプルアリティでマッチングすることは
;   静的型エラーです


; ============================================================
; 3. レコード型
; ============================================================

; --- 表層形式(式) ---
{.x 10 .y 20}      ; レコードリテラル（名前付きフィールド）
{.name "Alice" .age 30}

; フィールド名はドット(.)で始まります
; 空白区切りでフィールドを列挙します


; --- 正規形式(式) ---
{.x 10 .y 20}  ==> (record .x 10 .y 20)


; --- 型 ---
; レコード型は構造的型システムです
; フィールド名と型の組み合わせで型が決まります
; 
; 例:
; {.x Int .y Int}         : レコード型
; {.name String .age Int} : レコード型

; 型定義での使用例:
; (deftype Point (Point {.x Int .y Int}))
; (defalias Vec2 {.x Int .y Int})
; (defstruct Point {.x Int .y Int})


; --- フィールドアクセス ---
; deftype/defstruct の場合:
(.x record)        ; 短縮記法（型推論が必要）
(Point.x point)    ; 型名付きアクセサ（defstruct で自動生成）

; defalias の場合:
(.x record)        ; フィールド短縮記法のみ


; --- パターンマッチング(レコード) ---
; 表層パターン:
{.x 0 .y 0}        ; リテラルマッチング
{.x x .y y}        ; フィールド束縛
{.x x}             ; 部分マッチング（他のフィールドは無視）

; 脱糖規則(パターン):
; {.x px .y py}  ==> (record .x px .y py)

; 意味論:
; - レコードパターンは構造の分解を行います
; - パターン位置では評価は行われません
; - フィールド名の順序は問いません
; - 部分マッチングが可能です（必要なフィールドのみ指定）
; - deftype/defstruct で定義された型の場合、型構成子も使用できます:
;   (Point {.x x .y y})

; 例:
; (match point
;   {.x 0 .y 0} "origin"
;   {.x x .y y} (+ x y))
;
; deftype での使用:
; (match point
;   (Point {.x 0 .y 0}) "origin"
;   (Point {.x x .y y}) (+ x y))


; ============================================================
; 4. ハッシュマップ
; ============================================================

; - リテラル構文はありません
; - 正規形式でのみ構築可能です: (hash-map ...)
; - 特別なパターン構文はありません


; ============================================================
; 5. 配列
; ============================================================

; - リテラル構文はありません
; - 正規形式でのみ構築可能です: (array ...)
; - 特別なパターン構文はありません
```
