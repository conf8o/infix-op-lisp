# コレクション型

リストとタプルについては、特別なリテラル表現を用意し、パターンマッチングを可能にします。

```
; ============================================================
; 1. リスト
; ============================================================

; コードとしてのリストと、コレクションとしてのリストは区別します。
; `()` で囲われたデータはコードとしてのリストであり、`[]`で囲われたデータはコレクションとしてのリストです。

; --- 表層形式(式) ---
[]                 ; 空リスト
(x :: xs)          ; 中置cons(右結合)
[a b c]            ; リストリテラル(空白区切り)


; --- 正規形式(式) ---
[]                 ; プリミティブな空リスト値
(:: x xs)          ; 正規プレフィックス形式

; 脱糖規則:
; [e1 e2 ... en]
;   -> (e1 :: (e2 :: (... (en :: []) ...)))
;
; (x :: y)
;   -> (:: x y)


; --- 型 ---
; List : Type -> Type
; [] : (List a)
; (::) : a -> (List a) -> (List a)


; --- パターンマッチング(リスト) ---
; 表層パターン:
[]                 ; 空リストパターン
(p1 :: p2)         ; consパターン
[p1 p2 ... pn]     ; リストリテラルパターン

; 脱糖規則(パターン):
; []               ==> []
; (p1 :: p2)       ==> (:: p1 p2)
; [p1 ... pn]      ==> p1 :: (p2 :: (... (pn :: []) ...))

; 意味論:
; - パターン位置では評価は行われません
; - パターン中の(::)は構造の分解を行います
; - (::)は右結合です
; - リストパターンは構造束縛のためのものであり、関数呼び出しではありません


; ============================================================
; 2. タプル
; ============================================================

; --- 表層形式(式) ---
{}                 ; 0要素タプル (Unit)
{a}                ; 1要素タプル
{a b}              ; 2要素タプル
{a b c}            ; 3要素タプル
; 空白区切りで要素を並べます


; --- 正規形式(式) ---
{}         ==> (tuple)
{a}        ==> (tuple a)
{a b}      ==> (tuple a b)
{a b c}    ==> (tuple a b c)
; ...

; tuple はプリミティブな構築形式です
; レコード型と同様、構造的な型システムとして扱われます


; --- 型 ---
; タプル型はプリミティブ型です
; 要素数と各要素の型で型が決まります
; 
; 例:
; {}         : {}            (Unit型、0要素タプル型)
; {1}        : {Int}         (1要素タプル型)
; {1 "a"}    : {Int String}  (2要素タプル型)
; {1 "a" True} : {Int String Bool}  (3要素タプル型)

; 注記:
; 1      : Int
; {1}    : {Int}
; 1 != {1}  (異なる型)


; --- パターンマッチング(タプル) ---
; 表層パターン:
{}                 ; 0要素タプル
{p}                ; 1要素タプル
{p q}              ; 2要素タプル
{p q r}            ; 3要素タプル

; 脱糖規則(パターン):
; {}        ==> (tuple)
; {p}       ==> (tuple p)
; {p q}     ==> (tuple p q)
; {p q r}   ==> (tuple p q r)
; ...

; 意味論:
; - タプルパターンは構造の分解のみを行います
; - パターン位置では評価は行われません
; - 要素数は被検査対象の静的型により固定されます
; - 同じ被検査対象に対して複数の要素数でマッチングすることは
;   静的型エラーです


; ============================================================
; 3. レコード型
; ============================================================

; --- 表層形式(式) ---
{.x 10 .y 20}      ; レコードリテラル（名前付きフィールド）
{.name "Alice" .age 30}

; フィールド名はドット(.)で始まります
; 空白区切りでフィールドを列挙します


; --- 正規形式(式) ---
{.x 10 .y 20}  ==> (record .x 10 .y 20)


; --- 型 ---
; レコード型は構造的型システムです
; フィールド名と型の組み合わせで型が決まります
; 
; 例:
; {.x Int .y Int}         : レコード型
; {.name String .age Int} : レコード型

; 型定義での使用例:
; (deftype Point (Point {.x Int .y Int}))
; (defalias Vec2 {.x Int .y Int})
; (defstruct Point {.x Int .y Int})


; --- フィールドアクセス ---
; deftype/defstruct の場合:
(.x record)        ; 短縮記法（型推論が必要）
(Point.x point)    ; 型名付きアクセサ（defstruct で自動生成）

; defalias の場合:
(.x record)        ; フィールド短縮記法のみ


; --- パターンマッチング(レコード) ---
; 表層パターン:
{.x 0 .y 0}        ; リテラルマッチング
{.x x .y y}        ; フィールド束縛
{.x x}             ; 部分マッチング（他のフィールドは無視）

; 脱糖規則(パターン):
; {.x px .y py}  ==> (record .x px .y py)

; 意味論:
; - レコードパターンは構造の分解を行います
; - パターン位置では評価は行われません
; - フィールド名の順序は問いません
; - 部分マッチングが可能です（必要なフィールドのみ指定）
; - deftype/defstruct で定義された型の場合、型構成子も使用できます:
;   (Point {.x x .y y})

; 例:
; (match point
;   {.x 0 .y 0} "origin"
;   {.x x .y y} (+ x y))
;
; deftype での使用:
; (match point
;   (Point {.x 0 .y 0}) "origin"
;   (Point {.x x .y y}) (+ x y))


; ============================================================
; 4. ハッシュマップ
; ============================================================

; - リテラル構文はありません
; - 正規形式でのみ構築可能です: (hash-map ...)
; - 特別なパターン構文はありません


; ============================================================
; 5. 配列
; ============================================================

; - リテラル構文はありません
; - 正規形式でのみ構築可能です: (array ...)
; - 特別なパターン構文はありません
```
