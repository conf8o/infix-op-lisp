# infix-op-lisp

中置演算子を標準でサポートするLisp系関数型言語の仕様書です。Clojure, Haskell, Elm, OCamlをベースに、シンプルで一貫性のある構文を提供します。

## 基本構文

### コア

```
; ============================================================
; コア機能
; ============================================================

; 定義
(def name value)

(def (fname arg1 arg2 ...)
  expr)

; 束縛
(let (name1 expr1
      name2 expr2
      ...)
  body)

; パターンマッチング
(match value
  pattern1 expr1
  pattern2 expr2
  ...)

; if式
(if pred
  then-expr
  else-epxr)

; 条件分岐
(cond
  pred1 expr1
  pred2 expr2
  ...
  else  exprN)

; 無名関数
(fn (arg1 arg2 ...)
  body)

; 非モナディックな逐次実行
(begin
  expr1
  expr2
  ...
  result)
```

### 演算子の表層形式

```
; ============================================================
; 演算子の表層形式
; ============================================================

; 連鎖形式
; (a op b op c op ...)

; 例
; (a * b * c)
; (x |> f |> g)
```

### 副作用 / モナド

```
; ============================================================
; 副作用 / モナド
; ============================================================

(do
  (a <- ma)
  (n := x)
  expr)
```

### アプリカティブファンクタ

```
; ============================================================
; アプリカティブファンクタ
; ============================================================

(let+ (a aa
       b ab
       c ac)
  (f a b c))
```

## 中置演算子

### 概要

中置演算子を標準で搭載します。1つの括弧内では同じ演算子を連鎖できます。式中で異なる演算子を使う場合は明示的な括弧が必要です。そのため、演算子の優先順位は従来のLisp同様に存在しません。

### 中置演算子の宣言

```
; ============================================================
; 中置演算子の宣言
; ============================================================

; --- 連鎖可能な中置演算子 ---
; 要件: 二項演算子 + 結合方向のみ(代数的法則は不要)
; 表層: left/rightによる連鎖を許可
; 正規形: 二項ネスト(プレフィックスn項演算なし)
(infix right (->))
(infix right (::))
(infix left (|>))
(infix right (<<))

; --- プレーンな中置演算子 ---
; 表層: 二項のみ、連鎖不可
(infix non (=))
(infix non (:))
(infix non (<))
(infix non (>))


; ============================================================
; 注記 / 例
; ============================================================

; --- 連鎖可能: 二項ネスト正規形(結合方向に従う) ---
; (Int -> Int -> Int)     ==> (-> Int (-> Int Int))
; (x |> f |> (g a))       ==> (|> (|> x f) (g a))       ; left associative
; (f << g << h)           ==> (<< f (<< g h))           ; right associative
; (x :: xs :: [])         ==> (:: x (:: xs []))         ; right associative

; --- プレーン中置: 二項のみ、連鎖不可 ---
; (a = b)                 ==> (= a b)
; (a = b = c)             ==> error
; (x : Int)               ==> (: x Int)
```

## 型宣言

`(:)` も型宣言を行うための演算子ととらえ、前置スタイル、中置スタイルで型宣言できます。

```
; ============================================================
; 型宣言
; ============================================================

; --- 前置スタイル ---
(: x Int)
(: f (Int -> Int))
(: (+)  (Int -> Int -> Int))

; --- 中置スタイル(同じ情報、異なる表層形式) ---
(x : Int)
(f : (Int -> Int))
((+) : (Int -> Int -> Int))
```

## コレクション型

リストとタプルについては、特別なリテラル表現を用意し、パターンマッチングを可能にします。

```
; ============================================================
; 1. リスト
; ============================================================

; コードとしてのリストと、コレクションとしてのリストは区別します。
; `()` で囲われたデータはコードとしてのリストであり、`[]`で囲われたデータはコレクションとしてのリストです。

; --- 表層形式(式) ---
[]                 ; 空リスト
(x :: xs)          ; 中置cons(右結合)
[a b c]            ; リストリテラル(空白区切り)


; --- 正規形式(式) ---
[]                 ; プリミティブな空リスト値
(:: x xs)          ; 正規プレフィックス形式

; 脱糖規則:
; [e1 e2 ... en]
;   -> (e1 :: (e2 :: (... (en :: []) ...)))
;
; (x :: y)
;   -> (:: x y)


; --- 型 ---
; List : Type -> Type
; [] : (List a)
; (::) : a -> (List a) -> (List a)


; --- パターンマッチング(リスト) ---
; 表層パターン:
[]                 ; 空リストパターン
(p1 :: p2)         ; consパターン
[p1 p2 ... pn]     ; リストリテラルパターン

; 脱糖規則(パターン):
; []               ==> []
; (p1 :: p2)       ==> (:: p1 p2)
; [p1 ... pn]      ==> p1 :: (p2 :: (... (pn :: []) ...))

; 意味論:
; - パターン位置では評価は行われません
; - パターン中の(::)は構造の分解を行います
; - (::)は右結合です
; - リストパターンは構造束縛のためのものであり、関数呼び出しではありません


; ============================================================
; 2. タプル
; ============================================================

; --- 表層形式(式) ---
{}                 ; Unit(Tuple0)
{a}                ; Solo a(Tuple1)
{a b}              ; Tuple2
{a b c}            ; Tuple3
; 空白区切りの要素
; カンマは演算子ではありません


; --- 正規形式(式) ---
{}         ==> (Unit)
{a}        ==> (Solo a)
{a b}      ==> (Tuple2 a b)
{a b c}    ==> (Tuple3 a b c)
; ...

; TupleNコンストラクタは通常のコンストラクタです
; 正規形式では標準的な関数適用として使用されます


; --- 型 ---
; Unit   : Type
; Solo   : Type -> Type
; Tuple2 : Type -> Type -> Type
; Tuple3 : Type -> Type -> Type -> Type
; ...

; 例:
; 1      : Int
; {1}    : (Solo Int)
; 1 != {1}


; --- パターンマッチング(タプル) ---
; 表層パターン:
{}                 ; Unit
{p}                ; Solo
{p q}              ; Tuple2
{p q r}            ; Tuple3

; 脱糖規則(パターン):
; {}        ==> (Unit)
; {p}       ==> (Solo p)
; {p q}     ==> (Tuple2 p q)
; {p q r}   ==> (Tuple3 p q r)
; ...

; 意味論:
; - タプルパターンは構造の分解のみを行います
; - パターン位置では評価は行われません
; - アリティは被検査対象の静的型により固定されます
; - 同じ被検査対象に対して複数のタプルアリティでマッチングすることは
;   静的型エラーです


; ============================================================
; 3. ハッシュマップ
; ============================================================

; - リテラル構文はありません
; - 正規形式でのみ構築可能です: (hash-map ...)
; - 特別なパターン構文はありません


; ============================================================
; 4. 配列
; ============================================================

; - リテラル構文はありません
; - 正規形式でのみ構築可能です: (array ...)
; - 特別なパターン構文はありません
```

---

## 凡例：コメント装飾パターン

本仕様書では、コード例内のコメントで以下の装飾パターンを使用しています。

### 主要セクション

```scheme
; ============================================================
; セクション名
; ============================================================
```

主要な機能や概念の区切りを示します。

### サブセクション

```scheme
; --- サブセクション名 ---
```

主要セクション内の詳細な分類を示します。
- 前後に半角空白1文字を配置
- 例: `; --- 表層形式(式) ---`、`; --- 型 ---`

### 説明文

```scheme
; 通常の説明文
; - 箇条書き項目
```

通常のコメントや説明には装飾を付けません。箇条書きには `; -` を使用します。